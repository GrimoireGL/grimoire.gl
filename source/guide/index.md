---
type: doc
title: ノード及びコンポーネントの概要
order: 0
---

# GOML概要

Grimoire.jsの仕組みを理解するには、GOMLがどのように処理され、ノードやコンポーネントが構築されるのか、また属性がどのようにコンポーネントに割り当てられるのかを理解しなければなりません。
この仕組みはXMLに準拠した記法であるGOMLであるがゆえに見た目上HTMLに非常に近いものとなっていますが、より一貫した思想を持って作成されています。

## GOMLにおけるノード

```xml
<goml>
  <renderers>
    <renderer id="main" camera=".camera"/>
  </renderers>
  <scenes>
    <scene>
      <camera class="camera"/>
    </scene>
  </scenes>
</goml>
```

> 例1: GOMLの例

例えば、以上のような例をみるとGOMLにおけるノードとは`goml`、`renderers`、`renderer`、`scenes`、`scene`や`camera`になります。
どのようなノードであれ、`id`及び`class`を属性として持てます。

ノードは以下のような要素を持つデータ構造です。

* 子要素(0個以上)
* 親要素(0または1個)
* コンポーネント(0個以上)
* DOMParserによりパースされた対応するElement

**親要素**と**子要素**は言うまでもなく、ただのノードのツリー構造を表すためのものにすぎません。

### コンポーネントの概説

ノードはコンポーネントを持ちます。コンポーネントはGrimoire.jsにおける一定の処理を行う単位になります。
コンポーネントはノードからAttributeあるいは属性と呼ばれる値を受け取り、それに合わせた処理を行います。
**この概念は基本的にゲームエンジンであるUnityに近い思想なので、これを理解しているとこの概念の理解は早いでしょう。**

> UnityにおけるコンポーネントとGrimoire.jsにおけるコンポーネントの違い
>
> 以下のような関係を考えるとGrimoire.jsのコンポーネントは理解しやすいです。
>
> * UnityにおけるGameobjectはGOMLのノードにあたります。
> * UnityにおけるGameobjectのnameはノードのidにあたります。
> * UnityにおけるGameobjectのtagやlayerはノードのclassで実現できます。
> * UnityにおけるコンポーネントはGrimoire.jsにおけるコンポーネントと基本的に同義ですが、UnityはTransformを必ず持っているのが条件に対して、Grimoire.jsではどのようなノードでも持っていると保証されるコンポーネントは存在しません。
> * つまり、ノードではあるが、シーン中に存在する(Unityにおけるヒエラルキー)に存在するとは限らないものが存在します。

例えば、sceneの子要素として取り得るノード(例えば`camera`等)は必ず`Transformer`コンポーネントを所持しています。
Transformerコンポーネントはシーン中のモデルの姿勢(= 平行移動変形 + 回転変形 + 拡大変形)を計算します。

そのため、Transformerコンポーネントは以下のような属性を受け取ります。

* position・・・座標(vector3型)
* rotation・・・回転(vector3型)
* scale・・・拡大率(vector3型)

属性は必ず型を持ちます。(型については後述します。)

### ノードの定義

HTMLにおいては、近年のVirtual-DOMブームを除けば基本的にエンジニアが新たなHTMLタグを定義することはありません。
GOMLにおけるタグの定義は以下のような要素で成り立ちます。

* ノード名
* デフォルトコンポーネントリスト
* デフォルト値

デフォルトコンポーネントとはそのノードをインスタンス化した際に自動でコンポーネントとしてそのノードに割り当てられるコンポーネントです。
例えば、`goml`ノードには以下のようなコンポーネントがデフォルトコンポーネントリストに含まれています。(これが全てではありません)

* CanvasInitiator・・・対象となる位置に`<canvas>`タグを配置し、`WebGLコンテキスト`を初期化するコンポーネント
* LoopManager・・・レンダリングなどの処理のためにGrimoire.js中で行われるループを管理し、適切に更新を呼び出すためのコンポーネント
* ...etc

通常、デフォルトコンポーネントリストが空なノードは何の役割も持ちません。新たなノードを作るということは、**複数個のコンポーネントからなるノードがどう振る舞うか**をノードのデフォルトノードのリストに追加することと同義になります。

ノードはデフォルト値の連想配列を同時に所持します。このデフォルト値はコンポーネントの属性に同名の属性があり、かつユーザーがGOML側から新たな値を指定しない場合に用いられる値です。

### コンポーネントの定義

Grimoire.jsにおけるコンポーネントの定義は以下のような要素を持ちます。

* コンポーネント名
* 属性のリスト
* メソッドのリスト

属性のリストとは、そのコンポーネントがどのような値を入力として受け取るかの、名称と型の連想配列です。

メソッドのリストとは、そのコンポーネントの振る舞いを記述するためのメソッドです。詳しくは次の"メッセージのブロードキャスト"をみるとより概要が把握できるでしょう。

### メッセージのブロードキャスト

メッセージのブロードキャストはノードが持つ機能の一つです。あるノードにたいしてメッセージ"Update"を引数Xでブロードキャストするとは、あるノード及びその子孫全てにおいて、そのノードが持つコンポーネントの中に"Update"というメソッドがある場合これを引数Xを用いてこのメソッド呼びます。

例えば、ノードに対するブロードキャストは以下のような関数の定義になっています。

```typescript
function GomlNode#broadcastMessage(layer:number,message:string,...args:any[]);
function GomlNode#broadcastMessage(message:string,...args:[]);
```

注) `X#A`とはクラスXにおけるインスタンスメソッドAを指すものとします。

上記の定義を見ればわかる通り、第一引数に数値を受け取ることがあります。この数値layerは非負の整数であり、layer番目までの子要素に対してメッセージを送ることを意味します。
このため、`broadcastMessage(1,"Update",X)`は自分と自分の直下の子供の要素に対してのみ、Updateメソッドが存在する場合呼び出します。

このことからわかる通り、layerを省略してメッセージ名から記述を始めた際、つまり`broadcastMessage("Update",X)`を呼び出したような状況下においては、これは`broadcastMessage(Number.MAX_VAUE,"Update",X)`と全く同値です。

また、自分自身のコンポーネントだけを対象とする`broadcastMessage(0,"Update",X)`のエイリアスとして`sendMessage("Update",X)`が存在します。

Grimoire.jsにおける様々な処理はこのメッセージを利用して処理しています。

例えば、最初にScene内のUpdateが呼ばれるまで以下のようなメッセージのブロードキャストを通して初期化が行われます。

1. GOMLの読み込みによってすべてのノードの構築が終了すると、GomlParserは"TreeInitialized"メッセージをルート要素にsendMessageします。
2. `goml`ノード内にある`CanvasInitiator`がこのメッセージを受け取ると対象となるHTMLの位置に`<canvas>`を差し込みます。
3. 初期状態で読み込まなければいけないGOMLがすべて読み込まれると、`treePrepare`メッセージをルート要素からbroadcastMessageします。
4. この際、`goml`要素内の`LoadManager`が`canvas`上にロード画面を表示します。
5. その他の初期ロード時なければならないリソースはこの際に`LoadManager`コンポーネントに対してリソースの読み込み終了のためのハンドラーを登録します。
6. すべてのハンドラーが解決されると、`LoadManager`は`goml`ノードの`LoopManager`コンポーネントに対してループを開始させます。
7. 以降毎回のループで`scene`のルートから`LoopManager`が`broadcastMessage("Update")`を行います。

### 属性及び型

コンポーネントは属性を0個以上持つことが可能です。
属性は以下のようなデータ構造を持つものです。

* 属性名
* デフォルト値
* 型名

各型に対して定義されている以下のようなインターフェースを満たす関数を`コンバーター`と言います。

```typescript
function converter(rawValue:any):any;
```

通常、GOMLにより記述された属性は文字列として`converter`に渡され、コンポーネント内で利用する型に変換されます。
例えば、型に`vector3`を指定した場合はコンポーネント内部では、自動的にVector3クラスに変換されて取得できます。

> クエリと属性
>
> jQueryのようなクエリで検索できるNodeは、属性で検索する際にはいろいろな問題があります。
> jQueryとは異なり、属性名と属性値での検索(例えば`camera[target='text']`)はできません。
> これはコンバーターが逆変換が必ず可能とは限らないことと、すべての値が一意な表現と定まるとは限らないからです。
> これは例えばrotation3がオイラー角か四元数あるいは任意軸回転により表現された文字列か定まらず、それらを同一視することが難しい、あるいはパフォーマンス的に望ましくない場合が多く想定されるからです。
> ただし、クラスやidに関しては問題なく

# より発展的な内容

### ノードの継承
